Mutable/Reactive vs Immutable/Functional where to draw the line?

I believe there are many benefits with the functional coding style versus typical imperative style patterns. I find that common patterns such as loops can be written more succinctly and clearly using FP (Functional Programming) ideas e.g. map,filter etc. I also think there are powerful benefits to high order functions etc but I want to examine in this post the particular merits of mutable vs immutable state in large complex software systems and where a reactive approach combined with mutable state might have benefits in practice (or not?).

Unconstrained use of mutated state in software systems is often claimed to be one of the leading contributors to program complexity, debug time and ultimate fragility. This argument is particularly employed by many functional programming proponents and avoiding mutation is a key pillar of the functional style. From experience I can agree with this to some extent. In team based developments duplicates of particular variables/structures and classes can spawn unchecked leading to unnecessary complexity (a real shame that code quality tools can not catch this). This is not untypical in many systems I have seen but it is far from best practice in imperative/OO or declarative style coding. There are already many principles such as DRY (Do no Repeat Yourself) and uses of architectural models such as MVC, MVP, Observable which should, if followed correctly mean that this never occurs; but in reality there is still a problem â€¦..

Functional friendly languages such as Scala, Haskell etc provide full support for immutable versions of common data type collections such as map, lists etc. Taken alone use of these collections is not significantly different to the mutable equivalents, except the implementations tend to be more complex to support regeneration of the structure and therefore less efficient (although I do not think this performance loss is significant for many problems). However, the steps necessary to avoid mutable state can become quite extreme and there is definitely a point where the expression of the problem in an immutable version becomes unnecessarily complex. 

So, whilst I think avoid mutation where simple is definitely a great idea there seems to be a fuzzy gray area in the middle between these two extremes for many classes of problems. I would say the Obserable pattern (and all the variations of it) has been the core way complexity has been traditionally reduced for these circumstances but recently the Reactive approach has extended this pattern to make the use more flowing and natural in a wider range of circumstances. Many of the modern frameworks such a Comet, React etc rely on this kind of structure but I wanted to explore this concept in isolation.

The SmartVar library is an experimental javascript library providing support for reactive style compose-able models that can be readily integrated with other functional compatible libraries.
