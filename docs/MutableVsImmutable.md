##Musings on mutable vs immutable state

There are many benefits to functional coding style versus imperative style. I find that common patterns such as loops can be written more succinctly using FP (Functional Programming) ideas e.g. map,filter etc. I also think there are powerful benefits to high order functions etc but I want to examine the particular merits of mutable vs immutable state in large complex software systems and where a reactive approach combined with mutable state might have benefits in practice (or not?).

Unconstrained use of mutated state in software systems is often claimed to be one of the leading contributors to program complexity, debug time and ultimate fragility. This argument is particularly employed by many functional programming proponents and avoiding mutation is a key pillar of the functional style. From experience I can agree with this to some extent. In team based developments duplicates of particular variables/structures and classes can spawn unchecked leading to unnecessary complexity. In practice this is not untypical in many systems I have seen but it is far from best practice in imperative/OO or declarative style coding. There are already many principles such as DRY (Do no Repeat Yourself) and uses of architectural models such as MVC, MVP which should in fact, if followed correctly mean that this never occurs but in reality there is still a problem â€¦..

In many functional friendly languages such as Scala, Haskell etc there is full support for immutable versions of common data type collections such as map, lists etc. Taken alone use of these collections is not significantly different to the mutable equivalents except the implementations tend to be more complex to support regeneration of the structure and therefore less efficient (although I do not think this performance loss is significant in most non-real time domains). However, the steps necessary to avoid mutable state can become quite extreme and there is definitely a point where the expression of the problem in an immutable version becomes unnecessarily complex.

So, there seems to be a fuzzy gray area in the middle between these two extremes for many classes of problems. I would say the Obserable pattern has been the core way complexity has been traditionally reduced for these circumstances but recently the Reactive approach has extended this pattern to make the use more flowing and natural in a wider range of circumstances. Many of the modern frameworks such a Comet, React etc rely on this kind of structure but I wanted to explore this concept in isolation (and in Javascript/Typoscript  ). So, the SmartVar library is an experiment in building a library focused solely around this problem and should integrate well with other functionally compatible frameworks.
